---
title: "03 - Scaling"
author: "Cole LaCroix"
date: "2025-10-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install packages if not already installed
if(!require(geoR)) install.packages("geoR")
if(!require(spdep)) install.packages("spdep")
if(!require(gstat)) install.packages("gstat")
if(!require(pgirmess)) install.packages("pgirmess")
if(!require(ncf)) install.packages("ncf")

#load required packages
library(geoR)
library(spdep)      
library(gstat)
library(pgirmess)
library(ncf)
library(here)
library(ggplot2)
library(patchwork)   
library(viridis) 
```

```{r}
# load the matrix data into R
matrix <- read.csv(here("cactus_matrix.csv"), header = T)
head(matrix)
```

```{r}
# plot the data
plot(
  matrix[,"y"]~matrix[,"x"], # plot based on coodinates
     pch=21, # use point character 21 (a circle that can be filled)
  bg=gray.colors(12)[ # fill color of the circles comes from 12 shades of gray
    cut(matrix[,3],breaks = 12)  # divide the 3rd column of matrix into 12 groups (bins),
    ]
  )
```
Exercise Q1. Based on the plotting we learned from Lab1_disturbance, could you visualize the data in other way (including code and plot)?
(scroll to bottom for answers)

```{r}
# bind the x and y coordinate vectors from `matrix` into a 2-column matrix
coords <- cbind(matrix$x,matrix$y)

# name the two columns for clarity
colnames(coords) <- c("x", "y")

# Moran's I calculation
correlog.pgirmess <- pgirmess::correlog(
  coords, matrix$Height, 
  method = "Moran", 
  nbclass = 14, 
  alternative = "two.sided"
)

# summary
head(round(correlog.pgirmess, 2))
```

```{r}
# dist.class reflects the center of each bin
# coef shows the Moran coefficient for that distance
# n is the sample size for that distance (number of pairs of location used)

# plot the correlogram
plot(correlog.pgirmess[, "dist.class"], # selects the column "dist.class" from the object
     correlog.pgirmess[, "coef"], # selects the column "coef" from the object
     type = "b", pch = 19, # both points and lines are drawn; specifies the plotting symbol: a solid filled circle.
     xlab = "Distance class", # sets the label for the x-axis
     ylab = "Moran's I") # sets the label for the y-axis

# Add horizontal line at 0
abline(h = 0, lty = 2)
```

Exercise Q2 The plot above shows a Moran’s I correlogram for cactus height. (1) What does the positive Moran’s I at small distance classes indicate? (2) At what distance does the spatial autocorrelation become negligible or negative, and what ecological processes might explain this shift?

Exercise Q3 Does the Moran’s I curve intercept the y-axis? If not, explain why.

Exercise Q4 Many R packages can be used to calculate Moran’s I. Try using another one (e.g., ncf, ape, spatialreg) to calculate Moran’s I, and then compare it with the plot derived from the spdep package in a single figure.
par(mfrow = c(1,2)) plot(…) plot(…)


```{r}
# create a geoR object
geo.veg <- as.geodata(matrix)

# maximum distance to consider in correlogram/variogram
distmat <- as.matrix(dist(coords))
maxdist <- 2/3 * max(distmat)

par(mfrow = c(1,2))

# empirical semivariogram
emp.geoR <- variog(geo.veg, max.dist = maxdist)
```


```{r}
plot(emp.geoR)

# standardize break points to a minumum 10-m lag distance
emp.geoR_v1 <- variog(geo.veg, max.dist = maxdist,
                   breaks = c(seq(0,maxdist,by=10)))
```

```{r}
plot(emp.geoR_v1)
```
Exercise Q5 How to interpret the above semivariances?


```{r}
# exponential variogram
mlexp <- likfit(geo.veg, cov.model = "exp", ini = c(700,10))
```

```{r}
# spherical variogram
mlsph <- likfit(geo.veg, cov.model = "sph", ini = c(700,10))
```

```{r}
# model comparison
AIC(mlexp,mlsph)
summary(mlexp)
summary(mlsph)

```

Exercise Q6 Which model is better (based on the statistical results) and why? mlexp or mlsph?

```{r}
# grid with 1-unit intervals (1-m)
new.grid.1m <- expand.grid(0:max(matrix$x), 0:max(matrix$y))

# kriging: krige.control, cov.pars: partial sill, range
krig.geoR.exp <- krige.conv( # call the function krige.conv() from the geoR package, which performs kriging prediction (ordinary or simple kriging)
  geo.veg,
  locations = new.grid.1m, # specifies the prediction locations where kriging estimates should be calculated
  krige = krige.control(
    cov.pars = c(mlexp$cov.pars[1], # partial sill (variance explained by spatial structure)
                 mlexp$cov.pars[2]), # range (distance where spatial correlation drops off)
                 nugget = mlexp$nugget, # nugget effect (measurement error or micro-scale variation)
                 cov.model = "exp", # specify the covariance (variogram) model; here it is exponential
                 type.krige = "OK")) # specify the type of kriging: "OK" = Ordinary Kriging
```

```{r}
# extract predictions and SE into a dataframe
krig_df <- data.frame(
  x = new.grid.1m[,1],
  y = new.grid.1m[,2],
  pred = krig.geoR.exp$predict,
  se   = sqrt(krig.geoR.exp$krige.var)
)

# raw data plot (points colored by observed values)
p1 <- ggplot(data.frame(x=geo.veg$coords[,1], 
                        y=geo.veg$coords[,2],
                        z=geo.veg$data),
             aes(x, y, fill=z)) +
  geom_point(shape=21, size=1, color="black") +
  scale_fill_viridis(name=NULL, option="D") +
  coord_equal() +
  labs(title="Observed Data") +
  theme_minimal(base_size = 12) +
  theme(
  plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
  axis.text = element_text(size = 9),
  axis.title = element_text(size = 10)
)

# kriged estimates plot
p2 <- ggplot(krig_df, aes(x, y, fill=pred)) +
  geom_tile() +
  scale_fill_viridis(name=NULL, option="C") +
  coord_equal() +
  labs(title="Kriged Estimates") +
  theme_minimal(base_size = 12) +
  theme(
  plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
  axis.text = element_text(size = 9),
  axis.title = element_text(size = 10)
)

# kriging SE plot
p3 <- ggplot(krig_df, aes(x, y, fill=se)) +
  geom_tile() +
  scale_fill_viridis(name=NULL, option="B") +
  coord_equal() +
  labs(title="Kriging SE") +
  theme_minimal(base_size = 12) +
  theme(
  plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
  axis.text = element_text(size = 9),
  axis.title = element_text(size = 10)
)

# combine all three in one row
p1 + p2 + p3
```

Exercise Q7 After generating the kriging predictions and plotting both the estimated surface and the prediction standard errors (SE), compare the two plots and answer the following questions: (1) Where in the spatial domain are the SE highest? (2) Why SE is larger in those areas compared to others? (3) How would increasing the number or density of sampling points affect the kriging SE map?

------------

Exercise Q1. Based on the plotting we learned from Lab1_disturbance, could you visualize the data in other way (including code and plot)?
```{r}
summary(matrix)

## Binned heatmap of mean height (5 m bins)
ggplot(matrix, aes(x, y, z = Height)) +
  stat_summary_2d(fun = mean, bins = 30) +
  scale_fill_viridis(option = "C", name = "Mean height") +
  coord_equal() +
  labs(title = "Mean cactus height by 2D bins") +
  theme_minimal()

```

Exercise Q2 The plot above shows a Moran’s I correlogram for cactus height. (1) What does the positive Moran’s I at small distance classes indicate? (2) At what distance does the spatial autocorrelation become negligible or negative, and what ecological processes might explain this shift?

Q2 Answer: A positive Moran's I at short distances indicates that nearby plants have similar heights which means that they have a positive spatial autocorrelation. This probably means that they experience similar growing conditions and thus grow to similar heights. The Moran's I goes negative (slightly) at around the 15 distance mark. This is where the similarity in height disapears. Because it goes slightly negative, it may mean that this landscape experiences patch-gap patterns meaning limited resources create gaps between communities due to competition. 

Exercise Q3 Does the Moran’s I curve intercept the y-axis? If not, explain why.

Q3 Answer: No there is no y intercept because Moran's I is meant to display correlations between multiple objects at various distances. If an object was on the Y intercept, the only thing that it could compare itself to would be itself. This wouldn't tell us anything about spatial relationships. 

Exercise Q4 Many R packages can be used to calculate Moran’s I. Try using another one (e.g., ncf, ape, spatialreg) to calculate Moran’s I, and then compare it with the plot derived from the spdep package in a single figure.
par(mfrow = c(1,2)) plot(…) plot(…)

Q4 Answer: When both of the plots are side by side (see below) they are clearly very similar but still display some slight differences. From what chat is telling me, this has to do wit the say they are implemented with binning, pair-weighting, and distance standardization. 

```{r}
coords <- cbind(matrix$x, matrix$y)

# Compute both correlograms from scratch
correlog.pgirmess <- pgirmess::correlog(coords, matrix$Height,
                                        method="Moran", nbclass=14,
                                        alternative="two.sided")
z <- as.data.frame(correlog.pgirmess)

inc <- max(dist(coords)) / 14
cor_ncf <- ncf::correlog(x = matrix$x, y = matrix$y, z = matrix$Height,
                         increment = inc, resamp = 0)

# both plots
par(mfrow = c(1,2))
plot(z$dist.class, z$coef, type="b", pch=19,
     xlab="Distance class", ylab="Moran's I", main="pgirmess::correlog")
abline(h = 0, lty = 2)

plot(cor_ncf$mean.of.class, cor_ncf$correlation, type="b", pch=19,
     xlab="Distance class", ylab="Moran's I", main="ncf::correlog")
abline(h = 0, lty = 2)
par(mfrow = c(1,1))

```
Exercise Q5 How to interpret the above semivariances?

Q5 Answer: The semivariances look very similar. It appears that one has more available data than the other because a distance requirement was programmed into one of them. This make fewer points available for interpretation on one compared to the other. The one with more data represented is easier to see where the nugget (900, 1100), sill (1250, 1250), range (12, 15), monotonic rise (25, none?) occur. 

Exercise Q6 Which model is better (based on the statistical results) and why? mlexp or mlsph?

Q6 Answer: The exponential model has a smaller AIC which indicates a better fit though the difference is very small. This is likely because the expoential models change gradually over the distance as one would expect based on the semivariograms we already analyzed. The spherical model would probably suite stronger binary patch relationships where values quickly drop to zero. 

Exercise Q7 After generating the kriging predictions and plotting both the estimated surface and the prediction standard errors (SE), compare the two plots and answer the following questions: (1) Where in the spatial domain are the SE highest? (2) Why SE is larger in those areas compared to others? (3) How would increasing the number or density of sampling points affect the kriging SE map?

Q7 Answer: It appears from the plots that there is pretty even distribution of SE. Areas with yellow are high SE. Dark areas are low SE. This would indicate that there is a similar amount of uncertainty everywhere assuming that it is because there are evenly spaced sampling points. It could also be because the variation that is occuring is random and does not share spatial distribution or structure.  
