---
title: "04 - Scaled"
author: "Cole LaCroix"
date: "2025-10-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# set CRAN mirror (important when knitting)
options(repos = c(CRAN = "https://cloud.r-project.org"))

#install packages if not already installed
if(!require(here)) install.packages("here")
if(!require(terra)) install.packages("terra")
if(!require(spdep)) install.packages("spdep")
if(!require(pgirmess)) install.packages("pgirmess")
if(!require(mgcv)) install.packages("mgcv")

install.packages(
  "INLA",
  repos = c("https://inla.r-inla-download.org/R/stable", getOption("repos")),
  type = "binary"
)
```
```{r}
#load required packages
library(here)
library(terra)
library(spdep)
library(pgirmess)
library(mgcv)
library(INLA)
```
```{r}
# load the bird counts survey data
point.data <- read.csv('/Users/GitHub Projects/landscape_ecology_wTongQiu/Lab4_data/vath_2004.csv', header = T)

# create a matrix of spatial coordinates (EASTING and NORTHING) for each survey point
coords <- cbind(point.data$EASTING, point.data$NORTHING)

# load the elevation data
elev <- rast('/Users/GitHub Projects/landscape_ecology_wTongQiu/Lab4_data/elev.grd')

# create aspect and slope layers from the elevation layer
elev.terr <- terrain(elev, 
                     v = c("slope", "aspect"),
                     unit = "radians")

# make a multilayered file for extraction
layers <- c(elev, elev.terr)
names(layers) <- c("elev", "slope", "aspect")

# extract the values of the raster layers (e.g., elevation, slope, aspect, etc.) at each survey coordinate location
land.cov <- extract(x = layers, y = coords)

# combine the extracted elevation variables with the original point data into one data frame
point.data <- cbind(point.data, land.cov)

# plot the elevation layer and add the survey coordinates on top of the map
# pch controls point symbol, cex controls size, col controls color
plot(layers$elev, main = "Elevation with Bird Survey Points")
points(coords, pch = 19, cex = 0.8, col = "red")
```
```{r}
# transform the explanatory variables to a mean of 0 and a variance of 1., which can help improve model convergence and facilities comparing coefficients for different parameters.
point.data$elevs <- scale(point.data$elev, center = T, scale = T)
point.data$slopes <- scale(point.data$slope, center = T, scale = T)
point.data$aspects <- scale(point.data$aspect, center = T, scale = T)

# fit logistic regression models of varying complexity
VATH.elev <- glm(VATH ~ elevs, family = "binomial", data = point.data) 
VATH.all <- glm(VATH ~ elevs + slopes + aspects, family = "binomial", data = point.data) 
VATH.elev2 <- glm(VATH ~ elev + I(elev^2), family = "binomial", data= point.data)

# contract model fit using AIC
round(AIC(VATH.elev, VATH.all, VATH.elev2), 2)
```

```{r}
# create new data covering the full elevation range
# new, evenly spaced sequence of elevation values
# this allows you to compute smooth, model-based predictions across the entire elevation gradient
elev <- seq(min(point.data$elev), max(point.data$elev), length = 15)
newdata <- data.frame(elev = elev)

# predicting and computing uncertainty
# type = "link" gives predictions on the logit (linear) scale, not yet as probabilities

glm.pred <- predict(VATH.elev2, newdata = newdata, type = "link", se = T)
ucl <- glm.pred$fit + 1.96 * glm.pred$se.fit
lcl <- glm.pred$fit - 1.96 * glm.pred$se.fit

# back-transform to probability scale
glm.newdata <- data.frame(newdata, pred = plogis(glm.pred$fit),
                          lcl = plogis(lcl), ucl = plogis(ucl))

par(mfrow = c(1, 3))
    
# plot predicted relationship
plot(glm.newdata$elev, glm.newdata$pred,
     type = "l", lwd = 2, col = "black",
     ylim = c(0, 1), xlab = "Elevation (km)",
     ylab = "Occurrence", frame.plot = FALSE)
polygon(c(glm.newdata$elev, rev(glm.newdata$elev)),
        c(glm.newdata$lcl, rev(glm.newdata$ucl)),
        col = adjustcolor("skyblue", alpha.f = 0.4), border = NA)
lines(glm.newdata$elev, glm.newdata$pred, lwd = 2, col = "black")

# plot Moran’s I correlogram
coords.km <- coords / 1000
VATH.cor <- pgirmess::correlog(
  coords = coords.km,          # matrix of x,y coordinates
  z = point.data$VATH,      # numeric response (e.g., occurrence)
  method = "Moran",         # type of spatial autocorrelation
  nbclass = 30,             # number of distance bins
  alternative = "two.sided" # test direction
)
VATH.cor <- as.data.frame(VATH.cor)
plot(VATH.cor$dist.class, VATH.cor$coef,
     type = "l", lwd = 2, ylim = c(-0.3, 0.3),
     xlab = "Distance (km)", ylab = "Moran’s I", frame.plot = FALSE)
abline(h = 0, lty = "dashed")
lines(VATH.cor$dist.class, VATH.cor$coef, lwd = 2)
```
```{r}
# fit a polynomial (trend surface) logistic regression model for Varied Thrush occurrence
VATH.trend <- glm(VATH ~ elev + I(elev^2) + EASTING + I(EASTING ^2) + I(EASTING^3) + NORTHING + 
                  + I(NORTHING ^2) + I(NORTHING^3), family = "binomial", data = point.data)

# fit a Generalized Additive Model (GAM) for Varied Thrush occurrence
# s: smooth surface (spline) 
VATH.gam <- gam(VATH ~ elev + I(elev^2) + s(EASTING, NORTHING),
                family = "binomial", data = point.data)

# model results
options(scipen = 999) # increase penalty for scientific notation
summary(VATH.trend)
summary(VATH.gam)
```

```{r}
# create Thiessen polygons based on the sampling coordinates. Each polygon defines the area closest to a given point relative to all others
points.vec <- vect(coords, type = "points")
thiessen <- terra::voronoi(points.vec)
plot(thiessen) # plot the Thiessen polygons to visualize the spatial partitioning of the study area
points(points.vec, col = "red") # overlay the original sampling points in red for reference

# build neighborhood structure
adj_pairs <- terra::adjacent(thiessen, pairs = TRUE)

# convert adjacency list into a binary matrix
n_poly <- nrow(thiessen)
adj <- matrix(0, n_poly, n_poly)
adj[as.matrix(adj_pairs)] <- 1
adj <- Matrix::Matrix(adj, sparse = TRUE)  # convert to sparse matrix (dgTMatrix)

# assign a unique ID to each observation in the dataset. The ID variable will link each point to its corresponding spatial random effect.
point.data$id <- 1:nrow(point.data)

# fit a CAR model using INLA. 
# a spatial random effect 'f(id, model = "besag", graph = adj)'
VATH.inla <- inla(VATH ~ elev + I(elev^2) + f(id, model = "besag",
graph = adj), family = "binomial", data = point.data,
control.predictor = list(compute = TRUE))

summary(VATH.inla)
```
```{r}
# convert coordinates to kilometers
coords.km <- coords / 1000

# Intercept-only model
# this model assumes no predictors — just an overall mean (the intercept)
# it’s useful to see how strong the raw spatial pattern in the data is, without any environmental explanation.
VATH.int <- glm(VATH ~ 1,family = "binomial", data = point.data)
VATH.int.res <- residuals(VATH.int, type = "deviance")

# Quadratic elevation model
VATH.elev2.res <- residuals(VATH.elev2, type = "deviance")

# Trend surface model (polynomial coordinates)
VATH.trend.res <- residuals(VATH.trend, type = "deviance")

# GAM model (smooth spatial term)
VATH.gam.res <- residuals(VATH.gam, type = "deviance")

# INLA spatial model (CAR)
# need to manually calculate residuals to interpret spatial autocorrelation 
VATH.inla.fit <- VATH.inla$summary.fitted.values$mean
si <- ifelse(point.data$VATH==1, 1, -1)
VATH.inla.res <- si * (-2 * (point.data$VATH * log(VATH.inla.fit) + (1 - point.data$VATH) * log(1 - VATH.inla.fit)))^0.5

# compute Moran’s I correlograms for all residuals
cor.int   <- as.data.frame(pgirmess::correlog(coords.km, VATH.int.res,  method = "Moran", nbclass = 20))
cor.elev2 <- as.data.frame(pgirmess::correlog(coords.km, VATH.elev2.res, method = "Moran", nbclass = 20))
cor.trend <- as.data.frame(pgirmess::correlog(coords.km, VATH.trend.res, method = "Moran", nbclass = 20))
cor.gam   <- as.data.frame(pgirmess::correlog(coords.km, VATH.gam.res,   method = "Moran", nbclass = 20))
cor.inla  <- as.data.frame(pgirmess::correlog(coords.km, VATH.inla.res,  method = "Moran", nbclass = 20))

# plot correlograms side by side
par(mfrow = c(1, 5), mar = c(4, 4, 2, 1))
plot(cor.int$dist.class, cor.int$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Intercept-only"); abline(h = 0, lty = "dashed")

plot(cor.elev2$dist.class, cor.elev2$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Quadratic Elev."); abline(h = 0, lty = "dashed")

plot(cor.trend$dist.class, cor.trend$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Trend Surface"); abline(h = 0, lty = "dashed")

plot(cor.gam$dist.class, cor.gam$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "GAM"); abline(h = 0, lty = "dashed")

plot(cor.inla$dist.class, cor.inla$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "CAR"); abline(h = 0, lty = "dashed")
```
```{r}
par(mfrow = c(1, 3))

# prediction map from logistic regression model
glm.raster <- predict(model = VATH.elev2, object = layers)
glm.raster <- exp(glm.raster) / (1 + exp(glm.raster))
plot(glm.raster, main = "Non-spatial", 
     xlab = "Longitude", ylab = "Latitude")

# prediction map from logistic regression model
EASTING  <- init(layers$elev, "x")   # x-coordinate raster
NORTHING <- init(layers$elev, "y")   # y-coordinate raster

# combine predictors into one SpatRaster stack
predictors <- c(layers$elev, EASTING, NORTHING)
names(predictors) <- c("elev", "EASTING", "NORTHING")

trend.pred <- terra::predict(predictors, VATH.trend, type = "response")
plot(trend.pred, main = "Trend Surface Model",
     xlab = "Longitude", ylab = "Latitude")

# prediction map from GAM model
gam.pred <- terra::predict(predictors, VATH.gam, type = "response")
plot(gam.pred, main = "GAM",
     xlab = "Longitude", ylab = "Latitude")
```







