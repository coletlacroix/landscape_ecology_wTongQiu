---
title: "04 - Scaled"
author: "Cole LaCroix"
date: "2025-10-08"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# set CRAN mirror (important when knitting)
options(repos = c(CRAN = "https://cloud.r-project.org"))

```

```{r}
#load required packages
library(here)
library(terra)
library(spdep)
library(pgirmess)
library(mgcv)
library(INLA)
library(spatialEco)
```

```{r}
# load the bird counts survey data
point.data <- read.csv('/Users/GitHub Projects/landscape_ecology_wTongQiu/Lab4_data/vath_2004.csv', header = T)

# create a matrix of spatial coordinates (EASTING and NORTHING) for each survey point
coords <- cbind(point.data$EASTING, point.data$NORTHING)

# load the elevation data
elev <- rast('/Users/GitHub Projects/landscape_ecology_wTongQiu/Lab4_data/elev.grd')

# create aspect and slope layers from the elevation layer
elev.terr <- terrain(elev, 
                     v = c("slope", "aspect"),
                     unit = "radians")

# make a multilayered file for extraction
layers <- c(elev, elev.terr)
names(layers) <- c("elev", "slope", "aspect")

# extract the values of the raster layers (e.g., elevation, slope, aspect, etc.) at each survey coordinate location
land.cov <- extract(x = layers, y = coords)

# combine the extracted elevation variables with the original point data into one data frame
point.data <- cbind(point.data, land.cov)

# plot the elevation layer and add the survey coordinates on top of the map
# pch controls point symbol, cex controls size, col controls color
plot(layers$elev, main = "Elevation with Bird Survey Points")
points(coords, pch = 19, cex = 0.8, col = "red")
```
```{r}
# transform the explanatory variables to a mean of 0 and a variance of 1., which can help improve model convergence and facilities comparing coefficients for different parameters.
point.data$elevs <- scale(point.data$elev, center = T, scale = T)
point.data$slopes <- scale(point.data$slope, center = T, scale = T)
point.data$aspects <- scale(point.data$aspect, center = T, scale = T)

# fit logistic regression models of varying complexity
VATH.elev <- glm(VATH ~ elevs, family = "binomial", data = point.data) 
VATH.all <- glm(VATH ~ elevs + slopes + aspects, family = "binomial", data = point.data) 
VATH.elev2 <- glm(VATH ~ elev + I(elev^2), family = "binomial", data= point.data)

# contract model fit using AIC
round(AIC(VATH.elev, VATH.all, VATH.elev2), 2)
```

```{r}
# create new data covering the full elevation range
# new, evenly spaced sequence of elevation values
# this allows you to compute smooth, model-based predictions across the entire elevation gradient
# create new data covering the full elevation range
elev_seq <- seq(min(point.data$elev), max(point.data$elev), length = 15)
newdata  <- data.frame(elev = elev_seq)


# predicting and computing uncertainty
# type = "link" gives predictions on the logit (linear) scale, not yet as probabilities

glm.pred <- predict(VATH.elev2, newdata = newdata, type = "link", se = T)
ucl <- glm.pred$fit + 1.96 * glm.pred$se.fit
lcl <- glm.pred$fit - 1.96 * glm.pred$se.fit

# back-transform to probability scale
glm.newdata <- data.frame(newdata, pred = plogis(glm.pred$fit),
                          lcl = plogis(lcl), ucl = plogis(ucl))

par(mfrow = c(1, 3))
    
# plot predicted relationship
plot(glm.newdata$elev, glm.newdata$pred,
     type = "l", lwd = 2, col = "black",
     ylim = c(0, 1), xlab = "Elevation (km)",
     ylab = "Occurrence", frame.plot = FALSE)
polygon(c(glm.newdata$elev, rev(glm.newdata$elev)),
        c(glm.newdata$lcl, rev(glm.newdata$ucl)),
        col = adjustcolor("skyblue", alpha.f = 0.4), border = NA)
lines(glm.newdata$elev, glm.newdata$pred, lwd = 2, col = "black")

# plot Moran’s I correlogram
coords.km <- coords / 1000
VATH.cor <- pgirmess::correlog(
  coords = coords.km,          # matrix of x,y coordinates
  z = point.data$VATH,      # numeric response (e.g., occurrence)
  method = "Moran",         # type of spatial autocorrelation
  nbclass = 30,             # number of distance bins
  alternative = "two.sided" # test direction
)
VATH.cor <- as.data.frame(VATH.cor)
plot(VATH.cor$dist.class, VATH.cor$coef,
     type = "l", lwd = 2, ylim = c(-0.3, 0.3),
     xlab = "Distance (km)", ylab = "Moran’s I", frame.plot = FALSE)
abline(h = 0, lty = "dashed")
lines(VATH.cor$dist.class, VATH.cor$coef, lwd = 2)
```
```{r}
# fit a polynomial (trend surface) logistic regression model for Varied Thrush occurrence
VATH.trend <- glm(VATH ~ elev + I(elev^2) + EASTING + I(EASTING ^2) + I(EASTING^3) + NORTHING + 
                  + I(NORTHING ^2) + I(NORTHING^3), family = "binomial", data = point.data)

# fit a Generalized Additive Model (GAM) for Varied Thrush occurrence
# s: smooth surface (spline) 
VATH.gam <- gam(VATH ~ elev + I(elev^2) + s(EASTING, NORTHING),
                family = "binomial", data = point.data)

# model results
options(scipen = 999) # increase penalty for scientific notation
summary(VATH.trend)
summary(VATH.gam)
```

```{r}
# create Thiessen polygons based on the sampling coordinates. Each polygon defines the area closest to a given point relative to all others
points.vec <- vect(coords, type = "points")
thiessen <- terra::voronoi(points.vec)
plot(thiessen) # plot the Thiessen polygons to visualize the spatial partitioning of the study area
points(points.vec, col = "red") # overlay the original sampling points in red for reference

# build neighborhood structure
adj_pairs <- terra::adjacent(thiessen, pairs = TRUE)

# convert adjacency list into a binary matrix
n_poly <- nrow(thiessen)
adj <- matrix(0, n_poly, n_poly)
adj[as.matrix(adj_pairs)] <- 1
adj <- Matrix::Matrix(adj, sparse = TRUE)  # convert to sparse matrix (dgTMatrix)

# assign a unique ID to each observation in the dataset. The ID variable will link each point to its corresponding spatial random effect.
point.data$id <- 1:nrow(point.data)

# fit a CAR model using INLA. 
# a spatial random effect 'f(id, model = "besag", graph = adj)'
VATH.inla <- inla(VATH ~ elev + I(elev^2) + f(id, model = "besag",
graph = adj), family = "binomial", data = point.data,
control.predictor = list(compute = TRUE))

summary(VATH.inla)
```
```{r}
# convert coordinates to kilometers
coords.km <- coords / 1000

# Intercept-only model
# this model assumes no predictors — just an overall mean (the intercept)
# it’s useful to see how strong the raw spatial pattern in the data is, without any environmental explanation.
VATH.int <- glm(VATH ~ 1,family = "binomial", data = point.data)
VATH.int.res <- residuals(VATH.int, type = "deviance")

# Quadratic elevation model
VATH.elev2.res <- residuals(VATH.elev2, type = "deviance")

# Trend surface model (polynomial coordinates)
VATH.trend.res <- residuals(VATH.trend, type = "deviance")

# GAM model (smooth spatial term)
VATH.gam.res <- residuals(VATH.gam, type = "deviance")

# INLA spatial model (CAR)
# need to manually calculate residuals to interpret spatial autocorrelation 
VATH.inla.fit <- VATH.inla$summary.fitted.values$mean
si <- ifelse(point.data$VATH==1, 1, -1)
VATH.inla.res <- si * (-2 * (point.data$VATH * log(VATH.inla.fit) + (1 - point.data$VATH) * log(1 - VATH.inla.fit)))^0.5

# compute Moran’s I correlograms for all residuals
cor.int   <- as.data.frame(pgirmess::correlog(coords.km, VATH.int.res,  method = "Moran", nbclass = 20))
cor.elev2 <- as.data.frame(pgirmess::correlog(coords.km, VATH.elev2.res, method = "Moran", nbclass = 20))
cor.trend <- as.data.frame(pgirmess::correlog(coords.km, VATH.trend.res, method = "Moran", nbclass = 20))
cor.gam   <- as.data.frame(pgirmess::correlog(coords.km, VATH.gam.res,   method = "Moran", nbclass = 20))
cor.inla  <- as.data.frame(pgirmess::correlog(coords.km, VATH.inla.res,  method = "Moran", nbclass = 20))

# plot correlograms side by side
par(mfrow = c(1, 5), mar = c(4, 4, 2, 1))
plot(cor.int$dist.class, cor.int$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Intercept-only"); abline(h = 0, lty = "dashed")

plot(cor.elev2$dist.class, cor.elev2$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Quadratic Elev."); abline(h = 0, lty = "dashed")

plot(cor.trend$dist.class, cor.trend$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "Trend Surface"); abline(h = 0, lty = "dashed")

plot(cor.gam$dist.class, cor.gam$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "GAM"); abline(h = 0, lty = "dashed")

plot(cor.inla$dist.class, cor.inla$coef, type = "l", lwd = 2,
     ylim = c(-0.3, 0.3), xlab = "Distance (km)", ylab = "Moran’s I",
     main = "CAR"); abline(h = 0, lty = "dashed")
```
```{r}
par(mfrow = c(1, 3))

# prediction map from logistic regression model
glm.raster <- predict(model = VATH.elev2, object = layers)
glm.raster <- exp(glm.raster) / (1 + exp(glm.raster))
plot(glm.raster, main = "Non-spatial", 
     xlab = "Longitude", ylab = "Latitude")

# prediction map from logistic regression model
EASTING  <- init(layers$elev, "x")   # x-coordinate raster
NORTHING <- init(layers$elev, "y")   # y-coordinate raster

# combine predictors into one SpatRaster stack
predictors <- c(layers$elev, EASTING, NORTHING)
names(predictors) <- c("elev", "EASTING", "NORTHING")

trend.pred <- terra::predict(predictors, VATH.trend, type = "response")
plot(trend.pred, main = "Trend Surface Model",
     xlab = "Longitude", ylab = "Latitude")

# prediction map from GAM model
gam.pred <- terra::predict(predictors, VATH.gam, type = "response")
plot(gam.pred, main = "GAM",
     xlab = "Longitude", ylab = "Latitude")
```

Exercise Q1. Could you use the terrain function to calculate the Topographic Position Index (TPI) and visualize it in a similar way to the plot above (i.e., TPI with Bird Survey Points)?

```{r}
# exactly your look: 9x9 rectangle, scale = 45
tpi_result <- spatialEco::tpi(elev, scale = 45, win = "rectangle")
plot(tpi_result, main = "Topographic Position Index")
points(coords, pch = 10, cex = 0.8, col = "red")

```



Exercise Q2. Based on AIC and summary, which model performs best (VATH.elev, VATH.all, or VATH.elev2)? why?

AIC measure the fit of a model with a penalty for complexity. Lower AIC indicates that a model has a better combination of fit and complexity. VATH.elev2 has the lowest AIC. This is interesting because adding slope and aspect didn't help the VATH.all perform better than the quadratic term did. Adding this term allows the model to describe a non-linear relationship. 



Exercise Q3. Based on the elevation–occurrence relationship and the Moran’s I correlogram, what do these results suggest about how elevation (left panel) and distance (right panel) influence the species’ occurrence?

On the Occurrence vs Elevation graph, a distinct bell curve forms around the 1.2 km elevation then tapers down in either direction. This indicates that the bird's occurrence increases with elevation to a point then tapers down as habitat suitability decreases (this could be related to changes in forest type, cold, etc.). This means there apperas to be an optimal elevation for them. Regarding the Moran's I correlogram, the graph indicates that there is spatial autocorrelation, meaning that there is greater likelihood of occurrence base on proximity to another occurrence. The graph remains positive till about 100km distance. This means that without using spatial models, we might not get the best model fit. 


Exercise Q4 Please briefly describe your understanding of the above introduced models (i.e., trend surface, GAM, and CAR) and which you would prefer for your potential future spatial modeling project and why?

Trend Surface Model - This model adds polynomials of spatial coordinates to the regression to capture spatial gradients. In the case of our model, it improved the AIC. However, using the coordinates in this way is more useful for modeling very large-scale spatial dependencies. It is not as sensitive to local autocorrelation. 

GAM - This model uses smoothers that generalize data into smooth curves through fitting to subsets of the data. This method has greater flexibility for capturing non-linear responses across geographic space. This model explain's 31% of deviance in the data, meaning it highlights strong spatial structure. 

CAR - this model includes random spatial effects that consider local spatial dependence. When this effect is included, the elevation coefficients remain significant but shrink compared to non-spatial models. This likely means that part of the variation we thought was explained by elevation might actually be explained by spatial structure. 

Because I anticipate that there could be random spatial effects in many data sets that i could use in a localized project, I could see myself using the GAM or CAR. 


Exercise Q5 Which model appears to best remove spatial dependence from the residuals? Compare the estimated coefficients for elev and I(elev²) across the different models and describe how accounting for spatial dependence affects the magnitude and interpretation of these coefficients?

Spatial autocorrelation in the residuals appears to decrease as spatial structure is added to the models. The intercept-only and elevation models have strong positive I's at shorter distances. Trend surface has less of a correlation but it's still there. GAM is pretty much flat meaning there is essentially no correlation even at short distances. CAR trends pretty closely with quadratic elevation. GAM seems best. 

```{r}
summary(VATH.elev2)$coefficients[c("elev", "I(elev^2)"), ]
summary(VATH.trend)$coefficients[c("elev", "I(elev^2)"), ]

summary(VATH.gam)$p.table[c("elev", "I(elev^2)"), ]

VATH.inla$summary.fixed[c("elev", "I(elev^2)"), ]

```
Elevation had strong p values in the quadratic model. But, it got less strong in the GLM and GAM models while showing the same pattern. This shows that some of the effect of elevation was actually misrepresented and is more related to spatial auto correlation. When spatial structure is better accounted for, the impact of elevation becomes smaller and less certain. 


Exercise Q6 Considering how each model consider spatial dependence, which model captures the most realistic spatial variation in occurrence probability, and why?

The non-spatial model considers elevation only and likely ignores spatial conitnuity making things look patchy and rigid. The TSM adds polynomials for Easting and Norhting but is likely oversimplified and doesnt account for local structure well. the GAM smoothes for flexibility in local spatial patterns and captures fine scale patterns that are seen in the bird observations. This means that the GAM provides the best estimation of spatial variation and better acounts for ecological gradients and local clustering. 







